(function(){"use strict";var v;const x=(b,...t)=>postMessage({type:b,payload:t}),V=function(){var Q;const b=function(...e){throw new Error(e.join(" "))};globalThis.window===globalThis?b("This code cannot run from the main thread.","Load it as a Worker from a separate Worker."):(Q=navigator==null?void 0:navigator.storage)!=null&&Q.getDirectory||b("This API requires navigator.storage.getDirectory.");const t=Object.create(null);t.verbose=1;const j={0:console.error.bind(console),1:console.warn.bind(console),2:console.log.bind(console)},_=(e,...n)=>{t.verbose>e&&j[e]("OPFS asyncer:",...n)},h=(...e)=>_(2,...e),L=(...e)=>_(1,...e),w=(...e)=>_(0,...e),E=Object.create(null),p=new Set,k=function(e,n){const s=new URL(e,"file://irrelevant").pathname;return n?s.split("/").filter(a=>!!a):s},R=async function(e,n=!1){const s=k(e,!0),a=s.pop();let i=t.rootDir;for(const o of s)o&&(i=await i.getDirectoryHandle(o,{create:!!n}));return[i,a]},N=async e=>{if(e.syncHandle){h("Closing sync handle for",e.filenameAbs);const n=e.syncHandle;return delete e.syncHandle,delete e.xLock,p.delete(e.fid),n.close()}},H=async e=>{try{await N(e)}catch(n){L("closeSyncHandleNoThrow() ignoring:",n,e)}},U=async()=>{if(p.size)for(const e of p){const n=E[e];await H(n),h("Auto-unlocked",e,n.filenameAbs)}},A=async e=>{if(e.releaseImplicitLocks&&p.has(e.fid))return H(e)};class g extends Error{constructor(n,...s){super([...s,": "+n.name+":",n.message].join(" "),{cause:n}),this.name="GetSyncHandleError"}}g.convertRc=(e,n)=>{if(e instanceof g){if(e.cause.name==="NoModificationAllowedError"||e.cause.name==="DOMException"&&e.cause.message.indexOf("Access Handles cannot")===0)return t.sq3Codes.SQLITE_BUSY;if(e.cause.name==="NotFoundError")return t.sq3Codes.SQLITE_CANTOPEN}else if((e==null?void 0:e.name)==="NotFoundError")return t.sq3Codes.SQLITE_CANTOPEN;return n};const T=async(e,n)=>{if(!e.syncHandle){const s=performance.now();h("Acquiring sync handle for",e.filenameAbs);const a=6,i=2*t.asyncIdleWaitTime;let o=1,c=i;for(;;c=i*++o)try{e.syncHandle=await e.fileHandle.createSyncAccessHandle();break}catch(r){if(o===a)throw new g(r,"Error getting sync handle for",n+"().",a,"attempts failed.",e.filenameAbs);L("Error getting sync handle for",n+"(). Waiting",c,"ms and trying again.",e.filenameAbs,r),Atomics.wait(t.sabOPView,t.opIds.retry,0,c)}h("Got",n+"() sync handle for",e.filenameAbs,"in",performance.now()-s,"ms"),e.xLock||(p.add(e.fid),h("Acquired implicit lock for",n+"()",e.fid,e.filenameAbs))}return e.syncHandle},f=(e,n)=>{h(e+"() => notify(",n,")"),Atomics.store(t.sabOPView,t.opIds.rc,n),Atomics.notify(t.sabOPView,t.opIds.rc)},D=function(e,n){n.readOnly&&b(e+"(): File is read-only: "+n.filenameAbs)};let C=!1;const F={"opfs-async-shutdown":async()=>{C=!0,f("opfs-async-shutdown",0)},mkdir:async e=>{let n=0;try{await R(e+"/filepart",!0)}catch(s){t.s11n.storeException(2,s),n=t.sq3Codes.SQLITE_IOERR}f("mkdir",n)},xAccess:async e=>{let n=0;try{const[s,a]=await R(e);await s.getFileHandle(a)}catch(s){t.s11n.storeException(2,s),n=t.sq3Codes.SQLITE_IOERR}f("xAccess",n)},xClose:async function(e){p.delete(e);const n=E[e];let s=0;if(n){if(delete E[e],await N(n),n.deleteOnClose)try{await n.dirHandle.removeEntry(n.filenamePart)}catch(a){L("Ignoring dirHandle.removeEntry() failure of",n,a)}}else t.s11n.serialize(),s=t.sq3Codes.SQLITE_NOTFOUND;f("xClose",s)},xDelete:async function(...e){const n=await F.xDeleteNoWait(...e);f("xDelete",n)},xDeleteNoWait:async function(e,n=0,s=!1){let a=0;try{for(;e;){const[i,o]=await R(e,!1);if(!o||(await i.removeEntry(o,{recursive:s}),n!==4660))break;s=!1,(e=k(e,!0)).pop(),e=e.join("/")}}catch(i){t.s11n.storeException(2,i),a=t.sq3Codes.SQLITE_IOERR_DELETE}return a},xFileSize:async function(e){const n=E[e];let s=0;try{const a=await(await T(n,"xFileSize")).getSize();t.s11n.serialize(Number(a))}catch(a){t.s11n.storeException(1,a),s=g.convertRc(a,t.sq3Codes.SQLITE_IOERR)}await A(n),f("xFileSize",s)},xLock:async function(e,n){const s=E[e];let a=0;const i=s.xLock;if(s.xLock=n,!s.syncHandle)try{await T(s,"xLock"),p.delete(e)}catch(o){t.s11n.storeException(1,o),a=g.convertRc(o,t.sq3Codes.SQLITE_IOERR_LOCK),s.xLock=i}f("xLock",a)},xOpen:async function(e,n,s,a){const i="xOpen",o=t.sq3Codes.SQLITE_OPEN_CREATE&s;try{let c,r;try{[c,r]=await R(n,!!o)}catch(y){return t.s11n.storeException(1,y),void f(i,t.sq3Codes.SQLITE_NOTFOUND)}if(t.opfsFlags.OPFS_UNLINK_BEFORE_OPEN&a)try{await c.removeEntry(r)}catch{}const P=await c.getFileHandle(r,{create:o}),l=Object.assign(Object.create(null),{fid:e,filenameAbs:n,filenamePart:r,dirHandle:c,fileHandle:P,sabView:t.sabFileBufView,readOnly:!o&&t.sq3Codes.SQLITE_OPEN_READONLY&s,deleteOnClose:!!(t.sq3Codes.SQLITE_OPEN_DELETEONCLOSE&s)});l.releaseImplicitLocks=a&t.opfsFlags.OPFS_UNLOCK_ASAP||t.opfsFlags.defaultUnlockAsap,E[e]=l,f(i,0)}catch(c){w(i,c),t.s11n.storeException(1,c),f(i,t.sq3Codes.SQLITE_IOERR)}},xRead:async function(e,n,s){let a,i=0;const o=E[e];try{a=(await T(o,"xRead")).read(o.sabView.subarray(0,n),{at:Number(s)}),a<n&&(o.sabView.fill(0,a,n),i=t.sq3Codes.SQLITE_IOERR_SHORT_READ)}catch(c){w("xRead() failed",c,o),t.s11n.storeException(1,c),i=g.convertRc(c,t.sq3Codes.SQLITE_IOERR_READ)}await A(o),f("xRead",i)},xSync:async function(e,n){const s=E[e];let a=0;if(!s.readOnly&&s.syncHandle)try{await s.syncHandle.flush()}catch(i){t.s11n.storeException(2,i),a=t.sq3Codes.SQLITE_IOERR_FSYNC}f("xSync",a)},xTruncate:async function(e,n){let s=0;const a=E[e];try{D("xTruncate",a),await(await T(a,"xTruncate")).truncate(n)}catch(i){w("xTruncate():",i,a),t.s11n.storeException(2,i),s=g.convertRc(i,t.sq3Codes.SQLITE_IOERR_TRUNCATE)}await A(a),f("xTruncate",s)},xUnlock:async function(e,n){let s=0;const a=E[e];if(t.sq3Codes.SQLITE_LOCK_NONE===n&&a.syncHandle)try{await N(a)}catch(i){t.s11n.storeException(1,i),s=t.sq3Codes.SQLITE_IOERR_UNLOCK}f("xUnlock",s)},xWrite:async function(e,n,s){let a;const i=E[e];try{D("xWrite",i),a=n===(await T(i,"xWrite")).write(i.sabView.subarray(0,n),{at:Number(s)})?0:t.sq3Codes.SQLITE_IOERR_WRITE}catch(o){w("xWrite():",o,i),t.s11n.storeException(1,o),a=g.convertRc(o,t.sq3Codes.SQLITE_IOERR_WRITE)}await A(i),f("xWrite",a)}},z=async function(){const e=Object.create(null);for(let n of Object.keys(t.opIds)){const s=F[n];if(!s)continue;const a=Object.create(null);e[t.opIds[n]]=a,a.key=n,a.f=s}for(;!C;)try{if(Atomics.wait(t.sabOPView,t.opIds.whichOp,0,t.asyncIdleWaitTime)!=="not-equal"){await U();continue}const n=Atomics.load(t.sabOPView,t.opIds.whichOp);Atomics.store(t.sabOPView,t.opIds.whichOp,0);const s=e[n]??b("No waitLoop handler for whichOp #",n),a=t.s11n.deserialize(!0)||[];s.f?await s.f(...a):w("Missing callback for opId",n)}catch(n){w("in waitLoop():",n)}};navigator.storage.getDirectory().then(function(e){t.rootDir=e,globalThis.onmessage=function({data:n}){switch(n.type){case"opfs-async-init":{const s=n.args;for(const a in s)t[a]=s[a];t.verbose=s.verbose??1,t.sabOPView=new Int32Array(t.sabOP),t.sabFileBufView=new Uint8Array(t.sabIO,0,t.fileBufferSize),t.sabS11nView=new Uint8Array(t.sabIO,t.sabS11nOffset,t.sabS11nSize),Object.keys(F).forEach(a=>{Number.isFinite(t.opIds[a])||b("Maintenance required: missing state.opIds[",a,"]")}),(()=>{if(t.s11n)return t.s11n;const a=new TextDecoder,i=new TextEncoder("utf-8"),o=new Uint8Array(t.sabIO,t.sabS11nOffset,t.sabS11nSize),c=new DataView(t.sabIO,t.sabS11nOffset,t.sabS11nSize);t.s11n=Object.create(null);const r=Object.create(null);r.number={id:1,size:8,getter:"getFloat64",setter:"setFloat64"},r.bigint={id:2,size:8,getter:"getBigInt64",setter:"setBigInt64"},r.boolean={id:3,size:4,getter:"getInt32",setter:"setInt32"},r.string={id:4};const P=l=>{switch(l){case r.number.id:return r.number;case r.bigint.id:return r.bigint;case r.boolean.id:return r.boolean;case r.string.id:return r.string;default:b("Invalid type ID:",l)}};t.s11n.deserialize=function(l=!1){const y=o[0],S=y?[]:null;if(y){const u=[];let d,I,m,O=1;for(d=0;d<y;++d,++O)u.push(P(o[O]));for(d=0;d<y;++d){const q=u[d];q.getter?(m=c[q.getter](O,t.littleEndian),O+=q.size):(I=c.getInt32(O,t.littleEndian),O+=4,m=a.decode(o.slice(O,O+I)),O+=I),S.push(m)}}return l&&(o[0]=0),S},t.s11n.serialize=function(...l){if(l.length){const S=[];let u=0,d=1;for(o[0]=255&l.length;u<l.length;++u,++d)S.push((y=l[u],r[typeof y]||b("Maintenance required: this value type cannot be serialized.",y))),o[d]=S[u].id;for(u=0;u<l.length;++u){const I=S[u];if(I.setter)c[I.setter](d,l[u],t.littleEndian),d+=I.size;else{const m=i.encode(l[u]);c.setInt32(d,m.byteLength,t.littleEndian),d+=4,o.set(m,d),d+=m.byteLength}}}else o[0]=0;var y},t.s11n.storeException=t.asyncS11nExceptions?(l,y)=>{l<=t.asyncS11nExceptions&&t.s11n.serialize([y.name,": ",y.message].join(""))}:()=>{},t.s11n})(),h("init state",t),x("opfs-async-inited"),z();break}case"opfs-async-restart":C&&(L("Restarting after opfs-async-shutdown. Might or might not work."),C=!1,z())}},x("opfs-async-loaded")}).catch(e=>w("error initializing OPFS asyncer:",e))};globalThis.SharedArrayBuffer?globalThis.Atomics?globalThis.FileSystemHandle&&globalThis.FileSystemDirectoryHandle&&globalThis.FileSystemFileHandle&&globalThis.FileSystemFileHandle.prototype.createSyncAccessHandle&&((v=navigator==null?void 0:navigator.storage)!=null&&v.getDirectory)?V():x("opfs-unavailable","Missing required OPFS APIs."):x("opfs-unavailable","Missing Atomics API.","The server must emit the COOP/COEP response headers to enable that."):x("opfs-unavailable","Missing SharedArrayBuffer API.","The server must emit the COOP/COEP response headers to enable that.")})();
